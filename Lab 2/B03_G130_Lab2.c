#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  quad_encoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	3

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING = 1
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			case MOTOR_STOP:
				motor[motor1] = 0;

				if ( button1_pushed ) {
						exercise1_state = MOTOR_RUNNING;
						button1_pushed = false;
					}
				break;

			case MOTOR_RUNNING:
				motor[motor1] = 50;

				if (button2_pushed) {
					exercise1_state = MOTOR_STOP;
					button2_pushed = false;
				}
				break;

			default:
				//The program should never get here, all cases have been covered.
			}

	}//end while
}

void exercise_2()
{
	// state3 is never used
	enum T_test_state {
		state1 = 0,
		state2 = 1,
		//state3 = 2
	};

	resetMotorEncoder(motor1);
	T_test_state test_state = state1;

	while(true)
  {
    monitorInput();

    switch(test_state) {

    	// state1 is the idle state
			case state1:
				motor[motor1] = 0;

				if ( button1_pushed ) {
					test_state = state2;
					button1_pushed = false;
				}
				break;

			// state2 is in transit; it ignores any button presses
			case state2:
				motor[motor1] = 50;

				// Stops after 1 full rotation (~267 ticks)
				if (getMotorEncoder(motor1) >= 267) {
					resetMotorEncoder(motor1);
					test_state = state1;
				}
				break;

			default:
				//The program should never get here, all cases have been covered.
			}
    }// end while

} // end exercise_2

void exercise_3()
{
	enum my_states {
		OFF = 0,
		FORWARDS = 1,
		BACKWARDS = 2
	};

	int current_state = OFF;
	int next_state = OFF;

	resetMotorEncoder(motor1);

	while(true)
	{
	  monitorInput();

		switch (current_state) {

			case OFF:
				motor[motor1] = 0;

				// Button 1 sends it forwards
				if (button1_pushed) {
					current_state = FORWARDS;
					button1_pushed = false;
					next_state = OFF;

				// Button 2 sets it backwards
				} else if (button2_pushed) {
					current_state = BACKWARDS;
					button2_pushed = false;
					next_state = OFF;
				}
				break;

			case FORWARDS:
				motor[motor1] = 50;

				//Queues the next state if button is pressed
				if (button2_pushed) {
					next_state = BACKWARDS;
					button2_pushed = false;
				}

				// State only changes if the rotation is completed
				if (getMotorEncoder(motor1) >= 3000) {
					current_state = next_state;
					next_state = OFF;
					resetMotorEncoder(motor1);
					button1_pushed = false;
				}
				break;

			case BACKWARDS:
				motor[motor1] = -50;

				//Queues the next state if button is pressed
				if (button1_pushed) {
					next_state = FORWARDS;
					button1_pushed = false;
				}

				// State only changes if the rotation is completed
				if (getMotorEncoder(motor1) <= -3000) {
					current_state = next_state;
					next_state = OFF;
					resetMotorEncoder(motor1);
					button2_pushed = false;
				}
				break;

		}
  }//end while

}//end exercse_3


task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     default: //should never get here.
   } // end switch

}// end main
