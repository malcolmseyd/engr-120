#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Motor,  port9,           motorsRight,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10,          motorsLeft,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//tmotorVex393_MC29
//tmotorVex393_HBridge

const int SPEEDL = 50;
const int SPEEDR = 50;

const int TRAVELTIME = 1000 * 3.4;
const int TURNTIME   = 1000 * 1.05;

bool button1_pushed = false;
bool button1_released_yet = true;

bool button2_pushed = false;
bool button2_released_yet = true;


// This function implements a lock when the button is pressed.
// button#_enabled cannot be 'true' until the sensor is realeased again.
void updateSensors() {
	if(SensorValue(button1) && !button1_pushed && button1_released_yet) {
		button1_pushed = true;
		button1_released_yet = false;
	} else if (SensorValue(button1) == 0) {
		button1_pushed = false;
		button1_released_yet = true;
	}

	if(SensorValue(button2) && !button2_pushed && button2_released_yet) {
		button2_pushed = true;
		button2_released_yet = false;
	} else if (SensorValue(button2) == 0) {
		button2_pushed = false;
		button2_released_yet = true;
	}
}


task main()
{
	enum w_state {
		STOPPED = 0,
		FORWARDS,
		TURN
	};

	w_state wheel_state = STOPPED;
	motor[motorsLeft] = 0;
	motor[motorsRight] = 0;
	while(1){
		updateSensors();
		wait1Msec(25); // Account for errors with cheap sensors

		switch(wheel_state){
			case STOPPED:
				motor[motorsLeft] = 0;
				motor[motorsRight] = 0;

				if(button1_pushed){
					wheel_state = FORWARDS;
					button1_pushed = false;
				}

				if(button2_pushed){
					wheel_state = TURN;
					button2_pushed = false;
				}
				break;

			case FORWARDS:
				motor[motorsLeft] = SPEEDL;
				motor[motorsRight] = SPEEDR;

				wait1Msec(TRAVELTIME);
				wheel_state = STOPPED;
				break;

			case TURN:
				motor[motorsLeft] = SPEEDL;
				motor[motorsRight] = -SPEEDR;

				wait1Msec(TURNTIME);
				wheel_state = STOPPED;
				break;
		}
	}
}
