#pragma config(Sensor, in1,    motor_angle,    sensorPotentiometer)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Aiming for time < 1000; max_error < 20
static int MAX = 85;
static int ACC = 2;

/**********************************************************
** bool set_motor( int target )
** Runs motor to try and hit target angle
** Inputs:
**   target  - target reading from potentiometer.
** Output:
**    true   - motor has reached desired position
**    false  - motor has not hit target position
**
** Sets motor output.
** Reads motor from port motor_angle
**********************************************************/
bool set_motor( int target )
{
	int position = SensorValue[motor_angle];
	//writeDebugStream("%d\n", SensorValue[motor_angle]);

	// How far off the mark are we?
	int delta = target - position;

	// Our potentiometer is on backwards lol
	//delta *= -1;

	// If the motor is over the speed limit, scale it down.
	if ( delta > MAX ) {
	  delta = MAX;
  }
  else if ( delta < -MAX ) {
		delta = -MAX;
  }

  // Set the motor speed
  if(-ACC <= delta && delta <= ACC){
  	// If we're within the desired accuracy, stop the motor
  	motor[motor1] = 0;
  	return(true);

  } else {
    // Otherwise, set the motor speed to the distance away
    // Scale our speed down as we get closer
  	motor[motor1] = (int)(delta);
  	return(false);
  }


	// Return true, indicating we are at target position.
	return(true);

}

task main()
{
	// Target value to move motor towards.
	int target_value = 1500;

	// Time unitl motor hits target value.
	int first_time;
	// Maximum error after first time motor hits target value.
	int max_error;
	// Noted if motor hit target value.
	bool hit_target = false;

	int delta;

	// Reset timer.
	clearTimer(T1);

	// Run for either 5 seconds or until we get to target value
	while( time1(T1) < 5000 ) {

	  // Implements one iteration of control algorithm.
		set_motor( target_value );

		// If we haven't hit target value yet...
		if ( ! hit_target ) {
			// Check if we encounter target_value again.
			if ( SensorValue[motor_angle] == target_value ) {
				// Note hit target value.
				hit_target = true;

				// Record first time.
				first_time = time1(T1);

				// Reset maximum error value.
				max_error = 0;
			}
		} else {

		  // Find deviation from target value.
			delta = SensorValue[motor_angle] - target_value;

			// Find absolute value of deviation.
			if ( delta < 0 ) {
				delta = -1 * delta;
			}

			// If deviation is larger then previously found maximum deviation, update maximum deviation.
			if ( delta > max_error ) {
				max_error = delta;
			}

		} // if (! hit_target) else
	}  // match while( time1(T1) < 5000 )

	// Turn off motor
	motor[motor1] = 0;

	// Record results.
	if ( hit_target ) {
		writeDebugStream("MAX: %3d ACC: %2d ", MAX,ACC);
		writeDebugStream("First Time: %d\tMax Error: %d\n",first_time,max_error);
		} else {
		writeDebugStream("No convergence.\n");
	}

	// Infinite loop to keep DebugStream open so output can be read.
	while(1){
		set_motor(3000);
	}
}
