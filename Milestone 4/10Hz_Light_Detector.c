#pragma config(Sensor, in5,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl6,  StateLED,       sensorDigitalOut)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum T_State {
	LIGHT_OFF = 0,
	LIGHT_ON
};

const int beacon_threshold = 120;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLight()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

	} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
		} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

task main()
{
	T_State robot_state = LIGHT_OFF;
	int  beacon_level;

	while( true ) {



		// Update sensor values (must be called at least 20 times a second for proper performance).
		beacon_level = monitorLight();

		switch( robot_state ) {
		case LIGHT_OFF:
			SensorValue[StateLED] = 0;
			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_ON;
				} else {
				robot_state = LIGHT_OFF;
			}
			break;
		case LIGHT_ON:
			SensorValue[StateLED] = 1;
			if ( beacon_level > beacon_threshold ) {
				robot_state = LIGHT_ON;
				} else {
				robot_state = LIGHT_OFF;
			}
			break;
		default:
			// This should never happen.
			robot_state = LIGHT_OFF;

		} // switch( robot_state)

	}  // while(true)

}
